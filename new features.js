

	// ECMAScript 5 (2009 г.)
	
	// ECMAScript 6 (2015 г.) переименован в ECMAScript 2015
	
	// + дополнения на момент 2018 г.
	
	
	
	
	/* let и const ******/
	
	// вместо var - устарело
	
	let a = 1 // можно менять
	
	const a = 1 // нельзя менять
	
	const arr = [1, 2] // можно менять содержимое массива, но нельзя присвоить пустой массив
					   // То же самое и для объекта
					   
	// Лучше везде использовать const, а если нужно менять переменную, то let
	
	// var плоха тем, что видна во всей функции после объявления, а let и const видны
	// только внутри блока, где были объявлены
	
	
	
	
	/* Параметры по умолчанию ******/
	
	function f (a, b, c = 0) {}
	
	// Должны идти последними
	
	// Параметр по умолчанию применяется, если было передано undefined
	// null - это валидное значение! Значение параметра по умолчанию применено не будет
	
	// Параметром по умолчанию может быть объект со свойствами
	
	
	
	/* Rest параметр ******/
	
	const f = function (...args) {}
	
	// Это массив параметров. Ничего не передал -> пустой массив
	
	// Rest параметр должен быть последним и только один!
	
	
	
	/* Шаблонные строки ******/
	
	const name = 'Bob'
	const message = `now is ${Date.now()}. I am ${name}`
	
	// Позволяют получить многострочное значение без конкатенации ('today is ' + 'Monday'):
	
	const t = `<div>
			   </div` // пробелы и отступы от края сохраняются
			   
	
	
	/* Функции-стрелки (arrow-functions) ******/
	
	const f = x => x + 1
	
	f();
	
	const f = (x, y) => x + y
	
	const f = (x, y) => {
		a = x + y;
		
		return a;
	}
	
	// Легковесная версия обычных функций
	
	// Сохраняют this также при использовании в виде вложенных функций (в отличие от обычных функций, где this может быть потеряно)
	
	// Не имеют свойства prototype, их нельзя использовать в виде функций-конструкторов и вызывать с new !
	
	
	
	/* Object.assign({}, obj) ******/
	
	// Создаёт shallow copy (поверхностную копию)
	
	// Можно копировать свойства из нескольких объектов, но при этом свойства
	// с одинаковыми именами будут перезаписаны
	
	const obj = Object.assign({}, { a: 1}, { a: 2}); // obj.a = 2
	
	// Если свойство ссылается на массив, то при изменении массива в одном объекте, он
	// поменяется и в другом, т.к. shallow copy ссылается на тот же массив
	
	
	
	/* Spread оператор ******/
	
	// 2015 - для массивов, позже - для объектов
	
	// лаконичная запись Object.assign()
	
	const obj = { ...obj1, ...obj2 }
	
	// В объект перейдут все свойства из объектов. Одноимённые будут перезаписаны
	
	// Можно добавлять единичные свойства и методы:
	
	const obj = {
		...obj1,
		port: 8080, /* или просто port, если объявить его выше */
		connect(){}
	}
				  
	// spread оператор разворачивает объект, превращая его в список свойств, а массив
	// в список элементов
	
	
	
	/* Прототипы - базовая конструкция + нововведения ******/
	
	// Цепочка прототипов:
	// Движок javascript ищет вызываемое свойство или метод в объекте,
	// если не находит, идёт в прототип объекта, потом, если не найдено, в Object.prototype
	// если и там нет, вернёт undefined
	
	// Поэтому, если у нескольких объектов есть одинаковая функция, её можно вынести
	// в отдельный объект и установить его, как прототип для данного с помощью

	Object.setPrototypeOf(protoObj, obj) // Появился в ECMAScript 2015, но этот метод
										 // лучше не использовать - влияет на производительность
										 
	// Лучше использовать
	
	const obj = Object.create(protoObj) // создание объекта на основе прототипа
	obj.name = 'Bob' // создание индивидуальных свойств

	// Ещё лучше использовать слово new и функцию конструктор:
	
	function Animal(name) {
		this.name = name; // this - ссылка на создаваемый с использованием new объект
	}
	
	// Поскольку у любых функций (кроме arrow-functions) есть прототипы, то, чтобы при создании
	// объектов через new Animal('Dog') в каждый не копировалась функция, добавим её в прототип:
	
	Animal.prototype.say = function() { /* todo something */ }
	
	// У прототипа функции есть базовый прототип Object.prototype
	// Он содержит некоторые нужные методы:
	
	Object.prototype.toString()
	Object.prototype.valueOf(..)
	Object.prototype.hasOwnProperty(..) // и т.д.
	
	// Object.prototype будет в конце цепочки прототипов большинства объектов javascript
	
	// Чтобы создать объект без прототипа:
	
	const obj = Object.create(null) // null вместо прототипа
	
	
	
	
	/* Объекты ******/
	
	// Если значение и название свойства совпадают:
	
	// Было:
	
	const x = 10;
	const y = 10;
	
	const point = {
		x: x,
		y: y
	}
	
	// Теперь можно:
	
	const point = { x, y }
	
	// Объявление метода:
	
	// Было:
	
	const obj = {
		draw: function() {}
	}
	
	// Теперь можно:
	
	const obj = {
		draw() { }
	}
	
	// Можно использовать старый синтаксис
	
	
	
	
	/* Динамические названия свойств объекта ******/
	
	const prefix = 'some';
	
	const obj = {
		[prefix + 'age']: 20,      // obj.someage
		[prefix + 'name'] : 'Bob'  // obj.somename
	}
	
	
	
	/* Классы ******/
	
	// Классы - это синтаксический сахар ECMAScript 2015
	
	class Animal {
		constructor(name) {
			this.name = name // this - ссылка на создаваемый объект
		}
		
		say() {
			// todo
		}
	}
	
	class Bird extends Animal {}
	
	const duck = new Bird('duck');
	
	// по сути вышеприведённые конструкции - это завуалированное использование функций-конструкторов
	
	// Цепочка прототипов:
	
	// duck -> Bird.prototype -> Animal.prototype -> Object.prototype -> null
	
	// В дочернем классе может быть конструктор, он должен вызывать родительский:
	
	class Dog extends Animal {
		constructor() {
			super('Dog'); // Должен вызываться до первого обращения к this !!!
		}
		
		say() { // одноимённый метод переопределяет родительский
			super.say() // вызов родительского метода
		}
	}
	
	
	
	/* Деструктуризация ******/
	
	const person = {
		age: 10,
		name: 'Bob',
		weight: 50,
		
		info: {
			email: 'some@mail.ru',
			phone: '79788383838'
		}
	}
	
	const { age, name } = person; // получим две константы age и name
	
	// Получение данных из вложенного объекта:
	
	const { info: {email, phone} } = person // получим две константы из вложенного объекта info
	
	// Псевдонимы
	
	const { age: years } = person // получим константу с названием-псевдонимом years
	
	
	
	
	/* Значение по умолчанию при деструктуризации ******/
	
	const { age = 10 } = person
	
	// Для вложенного объекта:
	
	const { info: { email = 'empty' } = {}} = person // значение по умолчанию есть не только для свойства
												     // вложенного объекта, но и для самого объекта, если
													 // он не будет передан. Получим константу email = 'empty'
	
	
	function ({ age = 10 } = {}) { // Если в функцию ничего не передать, то будет получен age = 10
		// todo
	}
	
	
	
	/* Деструктуризация. Rest элемент ******/
	
	// по аналогии с Rest параметром
	
	const { age, ...others } = person // в others попадёт всё остальное
	
	// Rest элемент должен быть один в рамках одного объекта и идти последним
	
	// Для массивов можно использовать rest элементы и значения по умолчанию
	
	const arr = [ 1, 2, 3, 4, 5 ]
	
	const { a, b } = arr // получим две константы из элементов с индексами 0 и 1
	
	const { ,,a, b } = arr // пропустить два элемента и взять с индексами 2 и 3
	
	// В одном выражении можно деструктурировать объекты и массивы!
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	